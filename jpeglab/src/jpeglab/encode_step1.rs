use std::cmp::min;
use std::io;

use image::GrayImage;
use image::ImageBuffer;
use image::ImageFormat;
use image::RgbImage;

/// 我的 YUV 格式，总是使用 YUV422。
/// 图像已被填充为可被 MCU 整除（宽度为 16 的倍数，高度为 8 的倍数）。
/// 用 `self.padded_width()` 和 `self.padded_height()` 获取填充后的大小。
#[derive(Debug)]
pub struct MyYuvImage {
    pub original_width: usize,
    pub original_height: usize,
    /// `self.padded_height() * self.padded_width()`
    pub y: Vec<u8>,
    /// `self.padded_height() * (self.padded_width() / 2)`
    pub u: Vec<u8>,
    /// `self.padded_height() * (self.padded_width() / 2)`
    pub v: Vec<u8>,
}

impl MyYuvImage {
    pub fn padded_width(&self) -> usize {
        (self.original_width + 15) / 16 * 16
    }

    pub fn padded_height(&self) -> usize {
        (self.original_height + 7) / 8 * 8
    }

    pub fn new(width: usize, height: usize) -> Self {
        let mut ret = MyYuvImage {
            original_width: width,
            original_height: height,
            y: vec![],
            u: vec![],
            v: vec![],
        };

        let y_size = ret.padded_height() * ret.padded_width();
        ret.y.resize(y_size, u8::default());
        let uv_size = ret.padded_height() * (ret.padded_width() / 2);
        ret.u.resize(uv_size, u8::default());
        ret.v.resize(uv_size, u8::default());

        ret
    }
}

/// Generated by ChatGPT 4.
pub fn rgb_to_yuv(r: u8, g: u8, b: u8) -> (u8, u8, u8) {
    let r = r as f32;
    let g = g as f32;
    let b = b as f32;

    let y = 0.299 * r + 0.587 * g + 0.114 * b;
    let cb = -0.1687 * r - 0.3313 * g + 0.5 * b + 128.0;
    let cr = 0.5 * r - 0.4187 * g - 0.0813 * b + 128.0;

    (
        y.round().clamp(0.0, 255.0) as u8,
        cb.round().clamp(0.0, 255.0) as u8,
        cr.round().clamp(0.0, 255.0) as u8,
    )
}

/// Generated by ChatGPT 4.
pub fn yuv_to_rgb(y: u8, cb: u8, cr: u8) -> (u8, u8, u8) {
    let y = y as f32;
    let cb = cb as f32 - 128.0;
    let cr = cr as f32 - 128.0;

    let r = y + 1.402 * cr;
    let g = y - 0.344136 * cb - 0.714136 * cr;
    let b = y + 1.772 * cb;

    (
        r.round().clamp(0.0, 255.0) as u8,
        g.round().clamp(0.0, 255.0) as u8,
        b.round().clamp(0.0, 255.0) as u8,
    )
}

/// 第一步：输入 RGB 的图像，输出 YUV422 的图像。
/// YUV 的公式基于 ITU-R BT.601 标准。
pub fn encode_step1(image: &RgbImage) -> io::Result<MyYuvImage> {
    let (width, height) = image.dimensions();
    if width == 0 || height == 0 {
        return Err(io::Error::new(
            io::ErrorKind::InvalidData,
            "The image is empty",
        ));
    }

    let mut ret = MyYuvImage::new(width as usize, height as usize);

    let mut y_idx: usize = 0;
    let mut uv_idx: usize = 0;
    for y in 0..ret.padded_height() {
        for x in 0..ret.padded_width() {
            let ox = min(x, ret.original_width - 1);
            let oy = min(y, ret.original_height - 1);

            // 使用边缘像素填充。
            let pixel = image.get_pixel(ox as u32, oy as u32);
            let r = pixel[0];
            let g = pixel[1];
            let b = pixel[2];

            let (y, u, v) = rgb_to_yuv(r, g, b);
            ret.y[y_idx] = y;
            y_idx += 1;
            if x % 2 == 0 {
                ret.u[uv_idx] = u;
                ret.v[uv_idx] = v;
                uv_idx += 1;
            }
        }
    }

    assert_eq!(y_idx, ret.y.len());
    assert_eq!(uv_idx, ret.u.len());
    assert_eq!(uv_idx, ret.v.len());

    Ok(ret)
}

pub fn show_step1(result: &MyYuvImage) {
    println!(
        "[INFO] 将图片转换为 YUV422 格式，并填充为 MCU 的倍数，尺寸变为 {}x{}",
        result.padded_width(),
        result.padded_height()
    );
    let y_img = GrayImage::from_raw(
        result.padded_width() as u32,
        result.padded_height() as u32,
        result.y.clone(),
    )
    .unwrap();
    let u_img = ImageBuffer::from_fn(
        (result.padded_width() / 2) as u32,
        result.padded_height() as u32,
        |x, y| {
            let u_val = result.u[(y * (result.padded_width() as u32 / 2) + x) as usize];
            image::Rgb([0, u_val, 255 - u_val]) // 伪彩色
        },
    );
    let v_img = ImageBuffer::from_fn(
        (result.padded_width() / 2) as u32,
        result.padded_height() as u32,
        |x, y| {
            let v_val = result.v[(y * (result.padded_width() as u32 / 2) + x) as usize];
            image::Rgb([v_val, 0, 255 - v_val]) // 伪彩色
        },
    );
    let rgb_img = ImageBuffer::from_fn(
        result.original_width as u32,
        result.original_height as u32,
        |x, y| {
            let y_idx = (y * result.padded_width() as u32 + x) as usize;
            let u_idx = (y * (result.padded_width() as u32 / 2) + x / 2) as usize;
            let v_idx = (y * (result.padded_width() as u32 / 2) + x / 2) as usize;

            let y = result.y[y_idx];
            let u = result.u[u_idx];
            let v = result.v[v_idx];

            let (r, g, b) = yuv_to_rgb(y, u, v);

            image::Rgb([r, g, b])
        },
    );

    y_img
        .save_with_format("output/y.png", ImageFormat::Png)
        .unwrap_or_else(|_| {
            println!("[ERROR] 保存 Y 图像失败，考虑手动新建一个名为 output 的子文件夹");
        });
    u_img
        .save_with_format("output/u.png", ImageFormat::Png)
        .unwrap_or_else(|_| {
            println!("[ERROR] 保存 U 图像失败，考虑手动新建一个名为 output 的子文件夹");
        });
    v_img
        .save_with_format("output/v.png", ImageFormat::Png)
        .unwrap_or_else(|_| {
            println!("[ERROR] 保存 V 图像失败，考虑手动新建一个名为 output 的子文件夹");
        });
    rgb_img
        .save_with_format("output/initial_yuv_to_rgb.png", ImageFormat::Png)
        .unwrap_or_else(|_| {
            println!("[ERROR] 保存 RGB 图像失败，考虑手动新建一个名为 output 的子文件夹");
        });
}
